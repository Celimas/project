# Tyler Marklyn
# semantics.py
#
#
# This file includes the semantics for parsing a deck object
#
#

from Deck import * 
from itertools import product
from copy import deepcopy

class InvalidDeckError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return repr(self.message)

deck_of_cards = Deck()

class deckSemantics(object):
    def deck(self, ast):
        print "Finished processing deck: " + deck_of_cards
        return ast

    def traits(self, ast):
        print "Finished processing traits"
        return ast

    def trait_name(self, ast):
        return ast

    def trait_def(self, ast):
        traitname = "" #TODO, get name
        traittype = "" #TODO get type

        if traittype == "Boolean":
            traitvals = [True, False]

        elif traittype == "Num":
            traitvals = [1] #TODO get nums (and typecheck them)

        elif traittype == "Any":
            traitvals = [""] #TODO get strings
            
        else:
            raise InvalidDeckError("Invalid type on trait: " + traitname)


        t = Trait(traitname, traittype, traitvals)
        print "  Adding" + t + "to traits"
        deck_of_cards.addTrait(t)
        return ast

    def typed_collection(self, ast):
        return ast

    def cards(self, ast):
        print "Finished processing cards"
        return ast

    def card_rule(self, ast):
        foreach_traits = [] #TODO get list of foreach traits
        make_n = 1 #TODO get make number
        make_values = [] #TODO get list of other make arguments

        # This will be the dictionary of rules generated by the make portion of the rule
        make_dict = {}
        argcounter = 0

        for trait_name in deck_of_cards.trait_names:
            if trait_name not in foreach_traits:
                value = make_values[argcounter]
                
                if not deck_of_cards.checkValidVal(trait_name, value):
                    raise InvalidDeckError(str(value) + " is not a valid value for " + trait_name)

                make_dict[trait_name] = value
                argcounter += 1

        # Now we process the foreach part of the rule
        foreach_trait_vals = [] # a list of lists of vals for the traits
        for trait_name in foreach_traits:
            foreach_trait_vals.append(deck_of_cards.getValsForTrait(trait_name))

        all_foreach_combinations = list(product(*foreach_trait_vals))

        for combo in all_foreach_combinations:
            card_dict = deepcopy(make_dict)

            # Get the values out of the combo
            for i in range(len(foreach_traits)):
                card_dict[foreach_traits[i]] = combo[i]

            print "Adding " + make_n + " card(s) with value(s): " + card_dict

            # Make the cards
            for n in range(make_n):
                Deck.addCard(Card(card_dict))


        return ast

    def foreach_rule(self, ast):
        return ast

    def traits_rule(self, ast):
        return ast

    def combine_rule(self, ast):
        return ast

    def make_rule(self, ast):
        return ast

    def alphanumeric(self, ast):
        return ast

    def numeric(self, ast):
        return ast